#![feature(plugin)]
#![plugin(phf_macros)]

use std::str;

mod token;
pub use crate::token::TokenType;

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Token {
    // Keywords:
    Abort,
    Action,
    Add,
    After,
    All,
    Alter,
    Analyze,
    And,
    // Any,
    As,
    Asc,
    Attach,
    Autoincr,
    Before,
    Begin,
    Between,
    By,
    Cascade,
    Case,
    Cast,
    Check,
    Collate,
    ColumnKw,
    Commit,
    Conflict,
    Constraint,
    Create,
    Current,
    CurrentTimeKw(String),
    Database,
    Default,
    Deferrable,
    Deferred,
    Delete,
    Desc,
    Detach,
    Distinct,
    Do,
    Drop,
    Each,
    Else,
    End,
    Escape,
    Except,
    Exclusive,
    Exists,
    Explain,
    Fail,
    Filter,
    Following,
    For,
    Foreign,
    From,
    // Function,
    Group,
    Having,
    If,
    Ignore,
    Immediate,
    In,
    Index,
    Indexed,
    Initially,
    Insert,
    Instead,
    Intersect,
    Into,
    Is,
    IsNull,
    Join,
    JoinKw(String),
    Key,
    LikeKw(String),
    Limit,
    Match,
    No,
    Not,
    Nothing,
    NotNull,
    Null,
    Of,
    Offset,
    On,
    Or,
    Order,
    Over,
    Partition,
    Plan,
    Pragma,
    Preceding,
    Primary,
    Query,
    Raise,
    Range,
    Recursive,
    References,
    Reindex,
    Release,
    Rename,
    Replace,
    Restrict,
    Rollback,
    Row,
    Rows,
    Savepoint,
    Select,
    Set,
    Table,
    Temp,
    Then,
    To,
    Transaction,
    Trigger,
    Unbounded,
    Union,
    Unique,
    Update,
    Using,
    Vacuum,
    Values,
    View,
    Virtual,
    When,
    Where,
    Window,
    With,
    Without,

    // Identifiers:
    StringLiteral(String),
    Id(String),
    Variable(String),

    // Values:
    Any(String),
    Blob(String),
    Integer(String),
    Float(String),

    // Symbols:
    BitAnd,
    BitNot,
    BitOr,
    Comma,
    Concat,
    Dot,
    Equals,
    GreaterThan,
    GreaterEquals,
    LeftParen,
    LeftShift,
    LessEquals,
    LessThan,
    Minus,
    NotEquals,
    Plus,
    Reminder,
    RightParen,
    RightShift,
    Semi,
    Slash,
    Star,

    // special
    Eof,
}

impl TokenType {
    pub fn into_token(&self, value: &[u8]) -> Token {
        match self {
            // keywords
            TokenType::TK_ABORT => Token::Abort,
            TokenType::TK_ACTION => Token::Action,
            TokenType::TK_ADD => Token::Add,
            TokenType::TK_AFTER => Token::After,
            TokenType::TK_ALL => Token::All,
            TokenType::TK_ALTER => Token::Alter,
            TokenType::TK_ANALYZE => Token::Analyze,
            TokenType::TK_AND => Token::And,
            TokenType::TK_AS => Token::As,
            TokenType::TK_ASC => Token::Asc,
            TokenType::TK_ATTACH => Token::Attach,
            TokenType::TK_AUTOINCR => Token::Autoincr,
            TokenType::TK_BEFORE => Token::Before,
            TokenType::TK_BEGIN => Token::Begin,
            TokenType::TK_BETWEEN => Token::Between,
            TokenType::TK_BY => Token::By,
            TokenType::TK_CASCADE => Token::Cascade,
            TokenType::TK_CASE => Token::Case,
            TokenType::TK_CAST => Token::Cast,
            TokenType::TK_CHECK => Token::Check,
            TokenType::TK_COLLATE => Token::Collate,
            TokenType::TK_COLUMNKW => Token::ColumnKw,
            TokenType::TK_COMMIT => Token::Commit,
            TokenType::TK_CONFLICT => Token::Conflict,
            TokenType::TK_CONSTRAINT => Token::Constraint,
            TokenType::TK_CREATE => Token::Create,
            TokenType::TK_CURRENT => Token::Current,
            TokenType::TK_CTIME_KW => Token::CurrentTimeKw(from_bytes(value)),
            TokenType::TK_DATABASE => Token::Database,
            TokenType::TK_DEFAULT => Token::Default,
            TokenType::TK_DEFERRABLE => Token::Deferrable,
            TokenType::TK_DEFERRED => Token::Deferred,
            TokenType::TK_DELETE => Token::Delete,
            TokenType::TK_DESC => Token::Desc,
            TokenType::TK_DETACH => Token::Detach,
            TokenType::TK_DISTINCT => Token::Distinct,
            TokenType::TK_DO => Token::Do,
            TokenType::TK_DROP => Token::Drop,
            TokenType::TK_EACH => Token::Each,
            TokenType::TK_ELSE => Token::Else,
            TokenType::TK_END => Token::End,
            TokenType::TK_ESCAPE => Token::Escape,
            TokenType::TK_EXCEPT => Token::Except,
            TokenType::TK_EXCLUSIVE => Token::Exclusive,
            TokenType::TK_EXISTS => Token::Exists,
            TokenType::TK_EXPLAIN => Token::Explain,
            TokenType::TK_FAIL => Token::Fail,
            TokenType::TK_FILTER => Token::Filter,
            TokenType::TK_FOLLOWING => Token::Following,
            TokenType::TK_FOR => Token::For,
            TokenType::TK_FOREIGN => Token::Foreign,
            TokenType::TK_FROM => Token::From,
            TokenType::TK_GROUP => Token::Group,
            TokenType::TK_HAVING => Token::Having,
            TokenType::TK_IF => Token::If,
            TokenType::TK_IGNORE => Token::Ignore,
            TokenType::TK_IMMEDIATE => Token::Immediate,
            TokenType::TK_IN => Token::In,
            TokenType::TK_INDEX => Token::Index,
            TokenType::TK_INDEXED => Token::Indexed,
            TokenType::TK_INITIALLY => Token::Initially,
            TokenType::TK_INSERT => Token::Insert,
            TokenType::TK_INSTEAD => Token::Instead,
            TokenType::TK_INTERSECT => Token::Intersect,
            TokenType::TK_INTO => Token::Into,
            TokenType::TK_IS => Token::Is,
            TokenType::TK_ISNULL => Token::IsNull,
            TokenType::TK_JOIN => Token::Join,
            TokenType::TK_JOIN_KW => Token::JoinKw(from_bytes(value)),
            TokenType::TK_KEY => Token::Key,
            TokenType::TK_LIKE_KW => Token::LikeKw(from_bytes(value)),
            TokenType::TK_LIMIT => Token::Limit,
            TokenType::TK_MATCH => Token::Match,
            TokenType::TK_NO => Token::No,
            TokenType::TK_NOT => Token::Not,
            TokenType::TK_NOTHING => Token::Nothing,
            TokenType::TK_NOTNULL => Token::NotNull,
            TokenType::TK_NULL => Token::Null,
            TokenType::TK_OF => Token::Of,
            TokenType::TK_OFFSET => Token::Offset,
            TokenType::TK_ON => Token::On,
            TokenType::TK_OR => Token::Or,
            TokenType::TK_ORDER => Token::Order,
            TokenType::TK_OVER => Token::Over,
            TokenType::TK_PARTITION => Token::Partition,
            TokenType::TK_PLAN => Token::Plan,
            TokenType::TK_PRAGMA => Token::Pragma,
            TokenType::TK_PRECEDING => Token::Preceding,
            TokenType::TK_PRIMARY => Token::Primary,
            TokenType::TK_QUERY => Token::Query,
            TokenType::TK_RAISE => Token::Raise,
            TokenType::TK_RANGE => Token::Range,
            TokenType::TK_RECURSIVE => Token::Recursive,
            TokenType::TK_REFERENCES => Token::References,
            TokenType::TK_REINDEX => Token::Reindex,
            TokenType::TK_RELEASE => Token::Release,
            TokenType::TK_RENAME => Token::Rename,
            TokenType::TK_REPLACE => Token::Replace,
            TokenType::TK_RESTRICT => Token::Restrict,
            TokenType::TK_ROLLBACK => Token::Rollback,
            TokenType::TK_ROW => Token::Row,
            TokenType::TK_ROWS => Token::Row,
            TokenType::TK_SAVEPOINT => Token::Savepoint,
            TokenType::TK_SELECT => Token::Select,
            TokenType::TK_SET => Token::Set,
            TokenType::TK_TABLE => Token::Table,
            TokenType::TK_TEMP => Token::Temp,
            TokenType::TK_THEN => Token::Then,
            TokenType::TK_TO => Token::To,
            TokenType::TK_TRANSACTION => Token::Transaction,
            TokenType::TK_TRIGGER => Token::Trigger,
            TokenType::TK_UNBOUNDED => Token::Unbounded,
            TokenType::TK_UNION => Token::Union,
            TokenType::TK_UNIQUE => Token::Unique,
            TokenType::TK_UPDATE => Token::Update,
            TokenType::TK_USING => Token::Using,
            TokenType::TK_VACUUM => Token::Vacuum,
            TokenType::TK_VALUES => Token::Values,
            TokenType::TK_VIEW => Token::View,
            TokenType::TK_VIRTUAL => Token::Virtual,
            TokenType::TK_WHEN => Token::When,
            TokenType::TK_WHERE => Token::Where,
            TokenType::TK_WINDOW => Token::Window,
            TokenType::TK_WITH => Token::With,
            TokenType::TK_WITHOUT => Token::Without,
            // Identifiers
            TokenType::TK_STRING => Token::StringLiteral(from_bytes(value)),
            TokenType::TK_ID => Token::Id(from_bytes(value)),
            TokenType::TK_VARIABLE => Token::Variable(from_bytes(value)),
            // Values
            TokenType::TK_ANY => Token::Any(from_bytes(value)),
            TokenType::TK_BLOB => Token::Blob(from_bytes(value)),
            TokenType::TK_INTEGER => Token::Integer(from_bytes(value)),
            TokenType::TK_FLOAT => Token::Float(from_bytes(value)),
            // symbols
            TokenType::TK_BITAND => Token::BitAnd,
            TokenType::TK_BITNOT => Token::BitNot,
            TokenType::TK_BITOR => Token::BitOr,
            TokenType::TK_COMMA => Token::Comma,
            TokenType::TK_CONCAT => Token::Concat,
            TokenType::TK_DOT => Token::Dot,
            TokenType::TK_EQ => Token::Equals,
            TokenType::TK_GT => Token::GreaterThan,
            TokenType::TK_GE => Token::GreaterEquals,
            TokenType::TK_LP => Token::LeftParen,
            TokenType::TK_LSHIFT => Token::LeftShift,
            TokenType::TK_LE => Token::LessEquals,
            TokenType::TK_LT => Token::LessThan,
            TokenType::TK_MINUS => Token::Minus,
            TokenType::TK_NE => Token::NotEquals,
            TokenType::TK_PLUS => Token::Plus,
            TokenType::TK_REM => Token::Reminder,
            TokenType::TK_RP => Token::RightParen,
            TokenType::TK_RSHIFT => Token::RightShift,
            TokenType::TK_SEMI => Token::Semi,
            TokenType::TK_SLASH => Token::Slash,
            TokenType::TK_STAR => Token::Star,
            // special
            TokenType::TK_EOF => Token::Star,
        }
    }
}

fn from_bytes(bytes: &[u8]) -> String {
    unsafe { str::from_utf8_unchecked(bytes).to_owned() }
}

static KEYWORDS: phf::Map<&[u8], TokenType> = phf_map! {
    b"ABORT" => TokenType::TK_ABORT,
    b"ACTION" => TokenType::TK_ACTION,
    b"ADD" => TokenType::TK_ADD,
    b"AFTER" => TokenType::TK_AFTER,
    b"ALL" => TokenType::TK_ALL,
    b"ALTER" => TokenType::TK_ALTER,
    b"ANALYZE" => TokenType::TK_ANALYZE,
    b"AND" => TokenType::TK_AND,
    b"AS" => TokenType::TK_AS,
    b"ASC" => TokenType::TK_ASC,
    b"ATTACH" => TokenType::TK_ATTACH,
    b"AUTOINCREMENT" => TokenType::TK_AUTOINCR,
    b"BEFORE" => TokenType::TK_BEFORE,
    b"BEGIN" => TokenType::TK_BEGIN,
    b"BETWEEN" => TokenType::TK_BETWEEN,
    b"BY" => TokenType::TK_BY,
    b"CASCADE" => TokenType::TK_CASCADE,
    b"CASE" => TokenType::TK_CASE,
    b"CAST" => TokenType::TK_CAST,
    b"CHECK" => TokenType::TK_CHECK,
    b"COLLATE" => TokenType::TK_COLLATE,
    b"COLUMN" => TokenType::TK_COLUMNKW,
    b"COMMIT" => TokenType::TK_COMMIT,
    b"CONFLICT" => TokenType::TK_CONFLICT,
    b"CONSTRAINT" => TokenType::TK_CONSTRAINT,
    b"CREATE" => TokenType::TK_CREATE,
    b"CROSS" => TokenType::TK_JOIN_KW,
    b"CURRENT" => TokenType::TK_CURRENT,
    b"CURRENT_DATE" => TokenType::TK_CTIME_KW,
    b"CURRENT_TIME" => TokenType::TK_CTIME_KW,
    b"CURRENT_TIMESTAMP" => TokenType::TK_CTIME_KW,
    b"DATABASE" => TokenType::TK_DATABASE,
    b"DEFAULT" => TokenType::TK_DEFAULT,
    b"DEFERRABLE" => TokenType::TK_DEFERRABLE,
    b"DEFERRED" => TokenType::TK_DEFERRED,
    b"DELETE" => TokenType::TK_DELETE,
    b"DESC" => TokenType::TK_DESC,
    b"DETACH" => TokenType::TK_DETACH,
    b"DISTINCT" => TokenType::TK_DISTINCT,
    b"DO" => TokenType::TK_DO,
    b"DROP" => TokenType::TK_DROP,
    b"EACH" => TokenType::TK_EACH,
    b"ELSE" => TokenType::TK_ELSE,
    b"END" => TokenType::TK_END,
    b"ESCAPE" => TokenType::TK_ESCAPE,
    b"EXCEPT" => TokenType::TK_EXCEPT,
    b"EXCLUSIVE" => TokenType::TK_EXCLUSIVE,
    b"EXISTS" => TokenType::TK_EXISTS,
    b"EXPLAIN" => TokenType::TK_EXPLAIN,
    b"FAIL" => TokenType::TK_FAIL,
    b"FILTER" => TokenType::TK_FILTER,
    b"FOLLOWING" => TokenType::TK_FOLLOWING,
    b"FOR" => TokenType::TK_FOR,
    b"FOREIGN" => TokenType::TK_FOREIGN,
    b"FROM" => TokenType::TK_FROM,
    b"FULL" => TokenType::TK_JOIN_KW,
    b"GLOB" => TokenType::TK_LIKE_KW,
    b"GROUP" => TokenType::TK_GROUP,
    b"HAVING" => TokenType::TK_HAVING,
    b"IF" => TokenType::TK_IF,
    b"IGNORE" => TokenType::TK_IGNORE,
    b"IMMEDIATE" => TokenType::TK_IMMEDIATE,
    b"IN" => TokenType::TK_IN,
    b"INDEX" => TokenType::TK_INDEX,
    b"INDEXED" => TokenType::TK_INDEXED,
    b"INITIALLY" => TokenType::TK_INITIALLY,
    b"INNER" => TokenType::TK_JOIN_KW,
    b"INSERT" => TokenType::TK_INSERT,
    b"INSTEAD" => TokenType::TK_INSTEAD,
    b"INTERSECT" => TokenType::TK_INTERSECT,
    b"INTO" => TokenType::TK_INTO,
    b"IS" => TokenType::TK_IS,
    b"ISNULL" => TokenType::TK_ISNULL,
    b"JOIN" => TokenType::TK_JOIN,
    b"KEY" => TokenType::TK_KEY,
    b"LEFT" => TokenType::TK_JOIN_KW,
    b"LIKE" => TokenType::TK_LIKE_KW,
    b"LIMIT" => TokenType::TK_LIMIT,
    b"MATCH" => TokenType::TK_MATCH,
    b"NATURAL" => TokenType::TK_JOIN_KW,
    b"NO" => TokenType::TK_NO,
    b"NOT" => TokenType::TK_NOT,
    b"NOTHING" => TokenType::TK_NOTHING,
    b"NOTNULL" => TokenType::TK_NOTNULL,
    b"NULL" => TokenType::TK_NULL,
    b"OF" => TokenType::TK_OF,
    b"OFFSET" => TokenType::TK_OFFSET,
    b"ON" => TokenType::TK_ON,
    b"OR" => TokenType::TK_OR,
    b"ORDER" => TokenType::TK_ORDER,
    b"OUTER" => TokenType::TK_JOIN_KW,
    b"OVER" => TokenType::TK_OVER,
    b"PARTITION" => TokenType::TK_PARTITION,
    b"PLAN" => TokenType::TK_PLAN,
    b"PRAGMA" => TokenType::TK_PRAGMA,
    b"PRECEDING" => TokenType::TK_PRECEDING,
    b"PRIMARY" => TokenType::TK_PRIMARY,
    b"QUERY" => TokenType::TK_QUERY,
    b"RAISE" => TokenType::TK_RAISE,
    b"RANGE" => TokenType::TK_RANGE,
    b"RECURSIVE" => TokenType::TK_RECURSIVE,
    b"REFERENCES" => TokenType::TK_REFERENCES,
    b"REGEXP" => TokenType::TK_LIKE_KW,
    b"REINDEX" => TokenType::TK_REINDEX,
    b"RELEASE" => TokenType::TK_RELEASE,
    b"RENAME" => TokenType::TK_RENAME,
    b"REPLACE" => TokenType::TK_REPLACE,
    b"RESTRICT" => TokenType::TK_RESTRICT,
    b"RIGHT" => TokenType::TK_JOIN_KW,
    b"ROLLBACK" => TokenType::TK_ROLLBACK,
    b"ROW" => TokenType::TK_ROW,
    b"ROWS" => TokenType::TK_ROWS,
    b"SAVEPOINT" => TokenType::TK_SAVEPOINT,
    b"SELECT" => TokenType::TK_SELECT,
    b"SET" => TokenType::TK_SET,
    b"TABLE" => TokenType::TK_TABLE,
    b"TEMP" => TokenType::TK_TEMP,
    b"TEMPORARY" => TokenType::TK_TEMP,
    b"THEN" => TokenType::TK_THEN,
    b"TO" => TokenType::TK_TO,
    b"TRANSACTION" => TokenType::TK_TRANSACTION,
    b"TRIGGER" => TokenType::TK_TRIGGER,
    b"UNBOUNDED" => TokenType::TK_UNBOUNDED,
    b"UNION" => TokenType::TK_UNION,
    b"UNIQUE" => TokenType::TK_UNIQUE,
    b"UPDATE" => TokenType::TK_UPDATE,
    b"USING" => TokenType::TK_USING,
    b"VACUUM" => TokenType::TK_VACUUM,
    b"VALUES" => TokenType::TK_VALUES,
    b"VIEW" => TokenType::TK_VIEW,
    b"VIRTUAL" => TokenType::TK_VIRTUAL,
    b"WHEN" => TokenType::TK_WHEN,
    b"WHERE" => TokenType::TK_WHERE,
    b"WINDOW" => TokenType::TK_WINDOW,
    b"WITH" => TokenType::TK_WITH,
    b"WITHOUT" => TokenType::TK_WITHOUT
};
pub const MAX_KEYWORD_LEN: usize = 17;

pub fn is_keyword(name: &str) -> bool {
    if name.len() < 2 || name.len() > MAX_KEYWORD_LEN || !name.is_ascii() {
        return false;
    }
    if KEYWORDS.contains_key(name.as_bytes()) {
        return true;
    }
    unimplemented!()
}

/// word must be uppercase
pub fn keyword_token(word: &[u8]) -> Option<TokenType> {
    KEYWORDS.get(word).cloned()
}

pub fn is_identifier(name: &str) -> bool {
    if name.is_empty() {
        return false;
    }
    let bytes = name.as_bytes();
    is_identifier_start(bytes[0])
        && (bytes.len() == 1 || bytes[1..].iter().all(|b| is_identifier_continue(*b)))
}

pub fn is_identifier_start(b: u8) -> bool {
    (b >= b'A' && b <= b'Z') || b == b'_' || (b >= b'a' && b <= b'z') || b > b'\x7F'
}

pub fn is_identifier_continue(b: u8) -> bool {
    b == b'$'
        || (b >= b'0' && b <= b'9')
        || (b >= b'A' && b <= b'Z')
        || b == b'_'
        || (b >= b'a' && b <= b'z')
        || b > b'\x7F'
}
